# Свойства узлов: тип, тег и содержимое

#### [Свойства узлов: тип, тег и содержимое](https://learn.javascript.ru/basic-dom-node-properties)

### Классы DOM-узлов

У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу `<a>`, есть свойства, связанные со ссылками, а у соответствующего тегу `<input>` – свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.

Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является [EventTarget](https://dom.spec.whatwg.org/#eventtarget), от него наследует [Node](https://dom.spec.whatwg.org/#interface-node) и остальные DOM-узлы.

На рисунке ниже изображены основные классы:

![MainClasses](MainClasses.png)
Существуют следующие классы:

- [EventTarget](https://dom.spec.whatwg.org/#eventtarget) – это корневой «абстрактный» класс для всего.

  Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

- [Node](https://dom.spec.whatwg.org/#interface-node) – также является «абстрактным» классом, и служит основой для DOM-узлов.

  Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал `Node`).

- [Document](https://dom.spec.whatwg.org/#interface-document), по историческим причинам часто наследуется `HTMLDocument` (хотя последняя спецификация этого не навязывает) – это документ в целом.

  Глобальный объект document принадлежит именно к этому классу. Он служит точкой входа в DOM.

- [CharacterData](https://dom.spec.whatwg.org/#interface-characterdata) – «абстрактный» класс. Вот, кем он наследуется:

  - [Text](https://dom.spec.whatwg.org/#interface-text) – класс, соответствующий тексту внутри элементов. Например, `Hello` в `<p>Hello</p>`.
  - [Comment](https://dom.spec.whatwg.org/#interface-comment) – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.

- [Element](https://dom.spec.whatwg.org/#interface-element) – это базовый класс для DOM-элементов.

  Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children`. А также и методы поиска элементов: `getElementsByTagName`, `querySelector`.

  Браузер поддерживает не только HTML, но также XML и SVG. Таким образом, класс `Element` служит основой для более специфичных классов: `SVGElement`, `XmlElement` (они нам здесь не нужны) и `HTMLElement`.

- И наконец, [HTMLElement](v) является базовым классом для всех остальных HTML-элементов. Мы будем работать с ним большую часть времени.

  От него наследуются конкретные элементы:

  - [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) – класс для тега `<input>`,
  - [HTMLBodyElement](v) – класс для тега `<body>`,
  - [HTMLAnchorElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) – класс для тега `<a>`,
  - …и т.д.

Также существует множество других тегов со своими собственными классами, которые могут иметь определенные свойства и методы, в то время как некоторые элементы, такие как `<span>`, `<section>` и `<article>`, не имеют каких-либо определенных свойств, поэтому они являются экземплярами класса `HTMLElement`.

Таким образом, полный набор свойств и методов данного узла является результатом цепочки наследования.

Рассмотрим DOM-объект для тега `<input>`. Он принадлежит классу [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement).

Он получает свойства и методы из (в порядке наследования):

- `HTMLInputElement` – этот класс предоставляет специфичные для элементов формы свойства,
- `HTMLElement` – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
- `Element` – предоставляет типовые методы элемента,
- `Node` – предоставляет общие свойства DOM-узлов,
- `EventTarget` – обеспечивает поддержку событий (поговорим о них дальше),
- …и, наконец, он наследует от `Object`, поэтому доступны также методы «обычного объекта», такие как `hasOwnProperty`.

Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве `constructor.name` содержится его имя:

    alert( document.body.constructor.name ); // HTMLBodyElement

…Или мы можем просто привести его к строке:

    alert( document.body ); // [object HTMLBodyElement]

Проверить наследование можно также при помощи `instanceof`:

    alert( document.body instanceof HTMLBodyElement ); // true
    alert( document.body instanceof HTMLElement ); // true
    alert( document.body instanceof Element ); // true
    alert( document.body instanceof Node ); // true
    alert( document.body instanceof EventTarget ); // true

Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

В этом легко убедиться, если вывести в консоли браузера любой элемент через `console.dir(elem)`. Или даже напрямую обратиться к методам, которые хранятся в `HTMLElement.prototype`, `Element.prototype` и т.д.

**`console.dir(elem)` и `console.log(elem)`**

Большинство браузеров поддерживают в инструментах разработчика две команды: `console.log` и `console.dir`. Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.

Но для DOM-элементов они работают по-разному:

- `console.log(elem)` выводит элемент в виде DOM-дерева.
- `console.dir(elem)` выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

**Спецификация IDL**

В спецификации для описания классов DOM используется не JavaScript, а специальный язык [Interface description language](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (IDL), с которым достаточно легко разобраться.

В IDL все свойства представлены с указанием их типов. Например, `DOMString`, `boolean` и т.д.

### Свойство «nodeType»

Свойство `nodeType` предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.

Его значением является цифра:

- `elem.nodeType == 1` для узлов-элементов,
- `elem.nodeType == 3` для текстовых узлов,
- `elem.nodeType == 9` для объектов документа,
- В [спецификации](https://dom.spec.whatwg.org/#node) можно посмотреть остальные значения.

Например:

    <body>
      <script>
      let elem = document.body;

      // давайте разберёмся: какой тип узла находится в elem?
      alert(elem.nodeType); // 1 => элемент

      // и его первый потомок...
      alert(elem.firstChild.nodeType); // 3 => текст

      // для объекта document значение типа -- 9
      alert( document.nodeType ); // 9
      </script>
    </body>

В современных скриптах, чтобы узнать тип узла, мы можем использовать метод `instanceof` и другие способы проверить класс, но иногда `nodeType` проще использовать. Мы не можем изменить значение `nodeType`, только прочитать его.

### Тег: nodeName и tagName

Получив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`:

Например:

    alert( document.body.nodeName ); // BODY
    alert( document.body.tagName ); // BODY

Есть ли какая-то разница между `tagName` и `nodeName`?

Да, она отражена в названиях свойств, но не очевидна.

- Свойство `tagName` есть только у элементов Element.
- Свойство `nodeName` определено для любых узлов `Node`:
  - для элементов оно равно `tagName`.
  - для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

Другими словами, свойство `tagName` есть только у узлов-элементов (поскольку они происходят от класса `Element`), а `nodeName` может что-то сказать о других типах узлов.

Например, сравним tagName и nodeName на примере объекта document и узла-комментария:

  <body><!-- комментарий -->

    <script>
      // для комментария
      alert( document.body.firstChild.tagName ); // undefined (не элемент)
      alert( document.body.firstChild.nodeName ); // #comment

      // for document
      alert( document.tagName ); // undefined (не элемент)
      alert( document.nodeName ); // #document
    </script>

  </body>

Если мы имеем дело только с элементами, то можно использовать `tagName` или `nodeName`, нет разницы.

**Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре**

В браузере существуют два режима обработки документа: HTML и XML. HTML-режим обычно используется для веб-страниц. XML-режим включается, если браузер получает XML-документ с заголовком: `Content-Type: application/xml+xhtml`.

В HTML-режиме значения `tagName/nodeName` всегда записаны в верхнем регистре. Будет выведено `BODY` вне зависимости от того, как записан тег в HTML `<body>` или `<BoDy>`.

В XML-режиме регистр сохраняется «как есть». В настоящее время XML-режим применяется редко.

### innerHTML: содержимое элемента

Свойство [innerHTML](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) позволяет получить HTML-содержимое элемента в виде строки.

Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.

Пример ниже показывает содержимое `document.body`, а затем полностью заменяет его:

  <body>
    <p>Параграф</p>
    <div>DIV</div>

    <script>
      alert( document.body.innerHTML ); // читаем текущее содержимое
      document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
    </script>

  </body>
Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:

  <body>

    <script>
      document.body.innerHTML = '<b>тест'; // забыли закрыть тег
      alert( document.body.innerHTML ); // <b>тест</b> (исправлено)
    </script>

  </body>

**Скрипты не выполнятся**

Если `innerHTML` вставляет в документ тег `<script>` – он становится частью HTML, но не запускается.

#### Будьте внимательны: «innerHTML+=» осуществляет перезапись

Мы можем добавить HTML к элементу, используя `elem.innerHTML+="ещё html"`.

Вот так:

    chatDiv.innerHTML += "<div>Привет<img src='smile.gif'/> !</div>";
    chatDiv.innerHTML += "Как дела?";

На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись.

Технически эти две строки делают одно и то же:

    elem.innerHTML += "...";
    // это более короткая запись для:
    elem.innerHTML = elem.innerHTML + "..."

Другими словами, `innerHTML+=` делает следующее:

1. Старое содержимое удаляется.
2. На его место становится новое значение `innerHTML` (с добавленной строкой).

**Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.**

В примере `chatDiv` выше строка `chatDiv.innerHTML+="Как дела?"` заново создаёт содержимое HTML и перезагружает `smile.gif` (надеемся, картинка закеширована). Если в `chatDiv` много текста и изображений, то эта перезагрузка будет очень заметна.

Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании `innerHTML` большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введённым пользователем, то текст будет удалён. И т.д.

К счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`, которые мы изучим позже.

### outerHTML: HTML элемента целиком
