# Рекурсия и стек

#### [Рекурсия и стек](https://learn.javascript.ru/recursion)

### Два способа мышления

В качестве первого примера напишем функцию `pow(x, n)`, которая возводит `x` в натуральную степень `n`. Иначе говоря,
умножает `x` на само себя `n` раз.

Рассмотрим два способа её реализации.

1. Итеративный способ: цикл `for`:

   function pow(x, n) {
   let result = 1;

   // умножаем result на x n раз в цикле
   for (let i = 0; i < n; i++) {
   result *= x;
   }

   return result;
   }

   alert( pow(2, 3) ); // 8`

2. Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

   function pow(x, n) {
   if (n == 1) {
   return x;
   } else {
   return x * pow(x, n - 1);
   }
   }

   alert( pow(2, 3) ); // 8

Рекурсивное решение задачи обычно короче, чем итеративное.

Используя условный оператор `?` вместо `if`, мы можем переписать `pow(x, n)`, делая код функции более лаконичным, но всё
ещё легко читаемым:

    function pow(x, n) {
        return (n == 1) ? x : (x * pow(x, n - 1));
    }

Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов,
некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.

### Контекст выполнения, стек

Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).

[Контекст выполнения](https://tc39.github.io/ecma262/#sec-execution-contexts) – специальная внутренняя структура данных,
которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится
интерпретатор, локальные переменные функции, значение `this` (мы не используем его в данном примере) и прочую служебную
информацию.

Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:

- Выполнение текущей функции приостанавливается.
- Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – _стеке контекстов_ выполнения.
- Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
- После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где
  она была остановлена.

**Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.**

Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. Оптимизация требуется не везде,
как правило, нам важен хороший код, поэтому она и используется.

### Рекурсивные обходы

Как мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:

1. Либо это «простой» отдел с массивом – тогда мы сможем суммировать зарплаты в простом цикле.
2. Или это объект с `N` подотделами – тогда мы можем сделать N рекурсивных вызовов, чтобы получить сумму для каждого из
   подотделов, и объединить результаты.

       let company = { // тот же самый объект, сжатый для краткости
       sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
       development: {
       sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
       internals: [{name: 'Jack', salary: 1300}]
       }
       };
    
       // Функция для подсчёта суммы зарплат
       function sumSalaries(department) {
           if (Array.isArray(department)) { // случай (1)
            return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
           } else { // случай (2)
               let sum = 0;
               for (let subdep of Object.values(department)) {
               sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
               }
           return sum;
           }
       }
    
       alert(sumSalaries(company)); // 6700

Принцип прост: для объекта `{...}` используются рекурсивные вызовы, а массивы `[...]` являются «листьями» дерева
рекурсии, они сразу дают результат.

Обратите внимание, что в коде используются возможности, о которых мы говорили ранее:

- Метод `arr.reduce` из главы [Методы массивов](https://learn.javascript.ru/array-methods) для получения суммы элементов
  массива.
- Цикл `for(val of Object.values(obj))` для итерации по значениям объекта: `Object.values` возвращает массив значений.

### Рекурсивные структуры

Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях.

В HTML-документе HTML-тег может содержать:

- Фрагменты текста.
- HTML-комментарии.
- Другие HTML-теги (которые, в свою очередь, могут содержать фрагменты текста/комментарии или другие теги и т.д.).

### Связанный список

Представьте себе, что мы хотим хранить упорядоченный список объектов.

Естественным выбором будет массив:

    let arr = [obj1, obj2, obj3];

…Но у массивов есть недостатки. Операции «удалить элемент» и «вставить элемент» являются дорогостоящими.

Или же, если нам действительно нужны быстрые вставка/удаление, мы можем выбрать другую структуру данных,
называемую [связанный список](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA)
.

Элемент связанного списка определяется рекурсивно как объект с:

- value,
- next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.

      let list = {
        value: 1,
        next: {
            value: 2,
            next: {
                value: 3,
                next: {
                    value: 4,
                    next: null
                }
            }
        }
      };

Альтернативный код для создания:

    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };

Здесь мы можем ещё лучше увидеть, что есть несколько объектов, каждый из которых имеет `value` и `next`, указывающий на
соседа. Переменная `list` является первым объектом в цепочке, поэтому, следуя по указателям next из неё, мы можем
попасть в любой элемент.

Список можно легко разделить на несколько частей и впоследствии объединить обратно:

    let secondList = list.next.next;
    list.next.next = null;

Для объединения:

    list.next.next = secondList;

И, конечно, мы можем вставить или удалить элементы из любого места.

Например, для добавления нового элемента нам нужно обновить первый элемент списка:

    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };
    
    // добавление нового элемента в список
    list = { value: "new item", next: list };

Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента:

    list.next = list.next.next;

В отличие от массивов, нет перенумерации, элементы легко переставляются.

Естественно, списки не всегда лучше массивов. В противном случае все пользовались бы только списками.

Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом
массиве: `arr[n]` является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в `next` N раз,
чтобы получить N-й элемент.

…Но нам не всегда нужны такие операции. Например, нам может быть нужна очередь или
даже [двухсторонняя очередь](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D1%83%D1%85%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D1%8F%D1%8F_%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C)
– это упорядоченная структура, которая позволяет очень быстро добавлять/удалять элементы с обоих концов, но там не нужен
доступ в середину.

Списки могут быть улучшены:

- Можно добавить свойство prev в дополнение к `next` для ссылки на предыдущий элемент, чтобы легко двигаться по списку
  назад.
- Можно также добавить переменную `tail`, которая будет ссылаться на последний элемент списка (и обновлять её при
  добавлении/удалении элементов с конца).
- …Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения
  производительности и удобства.