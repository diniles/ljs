# Планирование: setTimeout и setInterval

#### [Планирование: setTimeout и setInterval](https://learn.javascript.ru/settimeout-setinterval)

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование
вызова».

Для этого существуют два метода:

- `setTimeout` позволяет вызвать функцию один раз через определённый интервал времени.
- `setInterval` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

### setTimeout

Синтаксис:

    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

Параметры:

`func|code`

Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но
это не рекомендуется.

`delay`

Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

`arg1, arg2…`

Аргументы, передаваемые в функцию (не поддерживается в IE9-)

С аргументами:

    function sayHi(phrase, who) {
        alert( phrase + ', ' + who );
    }
    
    setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

**Передавайте функцию, но не запускайте её**

### Отмена через clearTimeout

Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего
выполнения.

В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:

    let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
    alert(timerId); // идентификатор таймера
    
    clearTimeout(timerId);
    alert(timerId); // тот же идентификатор (не принимает значение null после отмены)

### setInterval

Метод `setInterval` имеет такой же синтаксис как setTimeout:

    let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

Все аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что функция запускается не один
раз, а периодически через указанный интервал времени.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

    // повторить с интервалом 2 секунды
    let timerId = setInterval(() => alert('tick'), 2000);
    
    // остановить вывод через 5 секунд
    setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

**Во время показа alert время тоже идёт**

### Вложенный setTimeout

Есть два способа запускать что-то регулярно.

Один из них `setInterval`. Другим является вложенный `setTimeout`. Например:

    /** вместо:
    let timerId = setInterval(() => alert('tick'), 2000);
    */
    
    let timerId = setTimeout(function tick() {
        alert('tick');
        timerId = setTimeout(tick, 2000); // (*)
    }, 2000);

Метод `setTimeout` выше планирует следующий вызов прямо после окончания текущего (*).

Вложенный `setTimeout` – более гибкий метод, чем `setInterval`. С его помощью последующий вызов может быть задан
по-разному в зависимости от результатов предыдущего.

**Вложенный `setTimeout` позволяет задать задержку между выполнениями более точно, чем `setInterval`.**

**Реальная задержка между вызовами `func` с помощью `setInterval` меньше, чем указано в коде!**

Это нормально, потому что время, затраченное на выполнение func, использует часть заданного интервала времени.

**ВложенныйsetTimeout гарантирует фиксированную задержку (здесь 100 мс).**

### setTimeout с нулевой задержкой

Особый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.

Это планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после
завершения выполнения текущего кода.

Так вызов функции будет запланирован сразу после выполнения текущего кода.

Например, этот код выводит «Привет» и затем сразу «Мир»:

    setTimeout(() => alert("Мир"));
    
    alert("Привет");

