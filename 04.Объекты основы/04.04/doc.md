# Копирование объектов и ссылки

#### https://learn.javascript.ru/object-methods

### Сокращённая запись метода

    // эти объекты делают одно и то же (одинаковые методы)
    
    user = {
      sayHi: function() {
      alert("Привет");
      }
    };
    
    // сокращённая запись выглядит лучше, не так ли?
    user = {
      sayHi() { // то же самое, что и "sayHi: function()"
      alert("Привет");
      }
    };

Как было показано, мы можем пропустить ключевое слово `function` и просто написать `sayHi()`.

Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (
что будет рассмотрено позже), но на данном этапе изучения это неважно. В большинстве случаев сокращённый синтаксис
предпочтителен.

### Ключевое слово «this» в методах

***Для доступа к информации внутри объекта метод может использовать ключевое слово this.***

Значение `this` – это объект «перед точкой», который использовался для вызова метода.

Например:

    let user = {
      name: "Джон",
      age: 30,
      
      sayHi() {
      // this - это "текущий объект"
      alert(this.name);
      }
    };
    
    user.sayHi(); // Джон

### «this» не является фиксированным

В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Оно может
использоваться в любой функции.

В этом коде нет синтаксической ошибки:

    function sayHi() {
      alert( this.name );
    }

Значение this вычисляется во время выполнения кода и зависит от контекста.

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:

    let user = { name: "Джон" };
    let admin = { name: "Админ" };
    
    function sayHi() {
      alert( this.name );
    }
    
    // используем одну и ту же функцию в двух объектах
    user.f = sayHi;
    admin.f = sayHi;
    
    // вызовы функции, приведённые ниже, имеют разное значение this
    // "this" внутри функции является ссылкой на объект, который указан "перед точкой"
    user.f(); // Джон  (this == user)
    admin.f(); // Админ  (this == admin)
    
    admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)

Правило простое: при вызове `obj.f()` значение `this` внутри `f` равно `obj`. Так что, в приведённом примере это `user`
или `admin`.

**Вызов без объекта: this == undefined**

Мы даже можем вызвать функцию вовсе без использования объекта:

    function sayHi() {
      alert(this);
    }

    sayHi(); // undefined

В строгом режиме (`use strict`) в таком коде значением `this` будет являться `undefined`. Если мы попытаемся получить
доступ к `name`, используя `this.name` – это вызовет ошибку.

В нестрогом режиме значением `this` в таком случае будет глобальный объект (`window` для браузера). Это – исторически
сложившееся поведение `this`, которое исправляется использованием строгого режима (`use strict`).

Обычно подобный вызов является ошибкой программирования. Если внутри функции используется `this`, тогда ожидается, что
она будет вызываться в контексте какого-либо объекта.

**Последствия свободного this**

В JavaScript `this` является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот
метод был объявлен, а зависит от того, какой объект вызывает метод (какой объект стоит «перед точкой»).

Эта идея вычисления `this` в момент исполнения имеет как свои плюсы, так и минусы. С одной стороны, функция может быть
повторно использована в качестве метода у различных объектов (что повышает гибкость). С другой стороны, большая гибкость
увеличивает вероятность ошибок.

### У стрелочных функций нет «this»

Стрелочные функции особенные: у них нет своего «собственного» `this`. Если мы используем `this` внутри стрелочной
функции, то его значение берётся из внешней «нормальной» функции.

Это является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь отдельное
значение `this`, а хотим брать его из внешнего контекста.

