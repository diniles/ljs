# Генераторы

#### [Генераторы](https://learn.javascript.ru/generators)

Обычные функции возвращают только одно-единственное значение (или ничего).

Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают
с перебираемыми объектами и позволяют легко создавать потоки данных.

### Функция-генератор

Для объявления генератора используется специальная синтаксическая конструкция: `function*`, которая называется
«функция-генератор».

Выглядит она так:

      function* generateSequence() {
         yield 1;
         yield 2;
         return 3;
      }

Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого
она возвращает специальный объект, так называемый «генератор», для управления её выполнением.

Вот, посмотрите:

      function* generateSequence() {
         yield 1;
         yield 2;
         return 3;
      }
      
      // "функция-генератор" создаёт объект "генератор"
      let generator = generateSequence();
      alert(generator); // [object Generator]

Выполнение кода функции ещё не началось:

Основным методом генератора является `next()`. При вызове он запускает выполнение кода до ближайшей
инструкции `yield <значение>` (значение может отсутствовать, в этом случае оно предполагается равным undefined). По
достижении `yield` выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:

Результатом метода `next()` всегда является объект с двумя свойствами:

- `value`: значение из `yield`.
    - `done`: `true`, если выполнение функции завершено, иначе `false`.
      Например, здесь мы создаём генератор и получаем первое из возвращаемых им значений:

  function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
  }

  let generator = generateSequence();

  let one = generator.next();

  alert(JSON.stringify(one)); // {value: 1, done: false}

На данный момент мы получили только первое значение, выполнение функции остановлено на второй строке:

Повторный вызов `generator.next()` возобновит выполнение кода и вернёт результат следующего `yield`:

      let two = generator.next();
      
      alert(JSON.stringify(two)); // {value: 2, done: false}

И, наконец, последний вызов завершит выполнение функции и вернёт результат `return`:

      let three = generator.next();
      
      alert(JSON.stringify(three)); // {value: 3, done: true}

Сейчас генератор полностью выполнен. Мы можем увидеть это по свойству `done:true` и обработать `value:3` как
окончательный результат.

Новые вызовы `generator.next()` больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут
возвращать один и тот же объект: `{done: true}`.

**`function* f(…)` или `function *f(…)`?**

Нет разницы, оба синтаксиса корректны.

Но обычно предпочтителен первый вариант, так как звёздочка относится к типу объявляемой сущности (`function*` –
«функция-генератор»), а не к её названию, так что резонно расположить её у слова `function`.

### Перебор генераторов

Как вы, наверное, уже догадались по наличию метода `next()`, генераторы
являются [перебираемыми](https://learn.javascript.ru/iterable) объектами.

Возвращаемые ими значения можно перебирать через `for..of`:

      function* generateSequence() {
         yield 1;
         yield 2;
         return 3;
      }
      
      let generator = generateSequence();
      
      for(let value of generator) {
         alert(value); // 1, затем 2
      }

Выглядит гораздо красивее, чем использование `.next().value`, верно?

…Но обратите внимание: пример выше выводит значение `1`, затем `2`. Значение `3` выведено не будет!

Это из-за того, что перебор через `for..of` игнорирует последнее значение, при котором `done: true`. Поэтому, если мы
хотим, чтобы были все значения при переборе через `for..of`, то надо возвращать их через `yield`:

      function* generateSequence() {
         yield 1;
         yield 2;
         yield 3;
      }
      
      let generator = generateSequence();
      
      for(let value of generator) {
         alert(value); // 1, затем 2, затем 3
      }

Так как генераторы являются перебираемыми объектами, мы можем использовать всю связанную с ними функциональность,
например оператор расширения `...`:

      function* generateSequence() {
         yield 1;
         yield 2;
         yield 3;
      }
      
      let sequence = [0, ...generateSequence()];
      
      alert(sequence); // 0, 1, 2, 3

В коде выше `...generateSequence()` превращает перебираемый объект-генератор в массив элементов (подробнее ознакомиться
с оператором расширения можно в
главе [Остаточные параметры и оператор расширения](https://learn.javascript.ru/rest-parameters-spread-operator#spread-operator))

