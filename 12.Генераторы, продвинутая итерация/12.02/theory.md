# Асинхронные итераторы и генераторы

#### [Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)

Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда мы загружаем что-то по частям
по сети. Асинхронные генераторы делают такой перебор ещё удобнее.

### Асинхронные итераторы

Асинхронные итераторы похожи на обычные итераторы, но имеют некоторые синтаксические отличия.

«Обычный» перебираемый объект, как подробно рассказано в
главе [Перебираемые объекты](https://learn.javascript.ru/iterable), выглядит примерно так:

    let range = {
        from: 1,
        to: 5,
        
        // for..of вызывает этот метод один раз в самом начале
        [Symbol.iterator]() {
            // ...возвращает объект-итератор:
            // далее for..of работает только с этим объектом, запрашивая следующее значение вызовом next()
            return {
            current: this.from,
            last: this.to,
            
              // next() вызывается на каждой итерации цикла for..of
              next() { // (2)
                // должен возвращать значение в виде объекта {done:.., value :...}
                if (this.current <= this.last) {
                  return { done: false, value: this.current++ };
                } else {
                  return { done: true };
                }
              }
            };
        }
    };
    
    for(let value of range) {
    alert(value); // 1, потом 2, потом 3, потом 4, потом 5
    }

Чтобы сделать объект итерируемым асинхронно:

1. Используется `Symbol.asyncIterator` вместо `Symbol.iterator`.
2. `next()` должен возвращать промис.
3. Чтобы перебрать такой объект, используется цикл `for await (let item of iterable)`.

Давайте создадим итерируемый объект `range`, как и в предыдущем примере, но теперь он будет возвращать значения
асинхронно, по одному в секунду:

    let range = {
        from: 1,
        to: 5,
        
        // for await..of вызывает этот метод один раз в самом начале
        [Symbol.asyncIterator]() { // (1)
            // ...возвращает объект-итератор:
            // далее for await..of работает только с этим объектом,
            // запрашивая у него следующие значения вызовом next()
            return {
            current: this.from,
            last: this.to,
            
              // next() вызывается на каждой итерации цикла for await..of
              async next() { // (2)
                // должен возвращать значение как объект {done:.., value :...}
                // (автоматически оборачивается в промис с помощью async)
        
                // можно использовать await внутри для асинхронности:
                await new Promise(resolve => setTimeout(resolve, 1000)); // (3)
        
                if (this.current <= this.last) {
                  return { done: false, value: this.current++ };
                } else {
                  return { done: true };
                }
              }
            };
        }
    };
    
    (async () => {
    
    for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
    }
    
    })()

Как видим, структура похожа на обычные итераторы:

1. Чтобы сделать объект асинхронно итерируемым, он должен иметь метод `Symbol.asyncIterator` `(1)`.
2. Этот метод должен возвращать объект с методом `next()`, который в свою очередь возвращает промис `(2)`.
3. Метод `next()` не обязательно должен быть `async`, он может быть обычным методом, возвращающим промис, но `async`
   позволяет использовать `await`, так что это удобно. Здесь мы просто делаем паузу на одну секунду `(3)`.
4. Для итерации мы используем `for await (let value of range)` `(4)`, добавляя «await» после «for». Он
   вызовет `range[Symbol.asyncIterator]()` один раз, а затем его метод `next()` для получения значений.

Вот небольшая шпаргалка:

|                                          | Итераторы | Асинхронные итераторы |
|------------------------------------------| ------ |-----------------|
| Метод для создания итерируемого объекта  | Symbol.iterator | Symbol.asyncIterator|
| next() возвращает	                       | любое значение | промис |
| для цикла используйте	                   | for..of	| for await..of|

**Оператор расширения `...` не работает асинхронно**

Функции, которые требуют обычных синхронных итераторов, не работают с асинхронными.

Например, оператор расширения (три точки `...`) не будет работать:

        alert( [...range] ); // Ошибка, нет Symbol.iterator

Это естественно, так как он ожидает `Symbol.iterator`, как и `for..of` без `await`. Ему не
подходит `Symbol.asyncIterator`.

### Асинхронные генераторы

Давайте вспомним генератор последовательности из главы [Генераторы](https://learn.javascript.ru/generators). Он
генерирует последовательность значений от `start` до `end`:

      function* generateSequence(start, end) {
         for (let i = start; i <= end; i++) {
            yield i;
         }
      }
      
      for(let value of generateSequence(1, 5)) {
         alert(value); // 1, потом 2, потом 3, потом 4, потом 5
      }

В обычных генераторах мы не можем использовать `await`. Все значения должны поступать синхронно: в `for..of` нет места
для задержки, это синхронная конструкция.

Но что если нам нужно использовать `await` в теле генератора? Для выполнения сетевых запросов, например.

Нет проблем, просто добавьте в начале `async`, например, вот так:

      async function* generateSequence(start, end) {
      
      for (let i = start; i <= end; i++) {
      
       // ура, можно использовать await!
       await new Promise(resolve => setTimeout(resolve, 1000));
   
       yield i;
      }
      
      }
      
      (async () => {
      
      let generator = generateSequence(1, 5);
      for await (let value of generator) {
         alert(value); // 1, потом 2, потом 3, потом 4, потом 5
      }
      
      })();

Теперь у нас есть асинхронный генератор, который можно перебирать с помощью `for await ... of`.

Это действительно очень просто. Мы добавляем ключевое слово `async`, и внутри генератора теперь можно
использовать `await`, а также промисы и другие асинхронные функции.

С технической точки зрения, ещё одно отличие асинхронного генератора заключается в том, что его метод `generator.next()`
теперь тоже асинхронный и возвращает промисы.

Из обычного генератора мы можем получить значения при помощи `result = generator.next()`. Для асинхронного нужно
добавить `await`, вот так:

      result = await generator.next(); // result = {value: ..., done: true/false}

