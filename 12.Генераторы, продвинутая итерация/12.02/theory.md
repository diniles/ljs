# Асинхронные итераторы и генераторы

#### [Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)

Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда мы загружаем что-то по частям
по сети. Асинхронные генераторы делают такой перебор ещё удобнее.

### Асинхронные итераторы

Асинхронные итераторы похожи на обычные итераторы, но имеют некоторые синтаксические отличия.

«Обычный» перебираемый объект, как подробно рассказано в
главе [Перебираемые объекты](https://learn.javascript.ru/iterable), выглядит примерно так:

    let range = {
        from: 1,
        to: 5,
        
        // for..of вызывает этот метод один раз в самом начале
        [Symbol.iterator]() {
            // ...возвращает объект-итератор:
            // далее for..of работает только с этим объектом, запрашивая следующее значение вызовом next()
            return {
            current: this.from,
            last: this.to,
            
              // next() вызывается на каждой итерации цикла for..of
              next() { // (2)
                // должен возвращать значение в виде объекта {done:.., value :...}
                if (this.current <= this.last) {
                  return { done: false, value: this.current++ };
                } else {
                  return { done: true };
                }
              }
            };
        }
    };
    
    for(let value of range) {
    alert(value); // 1, потом 2, потом 3, потом 4, потом 5
    }

Чтобы сделать объект итерируемым асинхронно:

1. Используется `Symbol.asyncIterator` вместо `Symbol.iterator`.
2. `next()` должен возвращать промис.
3. Чтобы перебрать такой объект, используется цикл `for await (let item of iterable)`.

Давайте создадим итерируемый объект `range`, как и в предыдущем примере, но теперь он будет возвращать значения
асинхронно, по одному в секунду:

    let range = {
        from: 1,
        to: 5,
        
        // for await..of вызывает этот метод один раз в самом начале
        [Symbol.asyncIterator]() { // (1)
            // ...возвращает объект-итератор:
            // далее for await..of работает только с этим объектом,
            // запрашивая у него следующие значения вызовом next()
            return {
            current: this.from,
            last: this.to,
            
              // next() вызывается на каждой итерации цикла for await..of
              async next() { // (2)
                // должен возвращать значение как объект {done:.., value :...}
                // (автоматически оборачивается в промис с помощью async)
        
                // можно использовать await внутри для асинхронности:
                await new Promise(resolve => setTimeout(resolve, 1000)); // (3)
        
                if (this.current <= this.last) {
                  return { done: false, value: this.current++ };
                } else {
                  return { done: true };
                }
              }
            };
        }
    };
    
    (async () => {
    
    for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
    }
    
    })()

Как видим, структура похожа на обычные итераторы:

1. Чтобы сделать объект асинхронно итерируемым, он должен иметь метод `Symbol.asyncIterator` `(1)`.
2. Этот метод должен возвращать объект с методом `next()`, который в свою очередь возвращает промис `(2)`.
3. Метод `next()` не обязательно должен быть `async`, он может быть обычным методом, возвращающим промис, но `async`
   позволяет использовать `await`, так что это удобно. Здесь мы просто делаем паузу на одну секунду `(3)`.
4. Для итерации мы используем `for await (let value of range)` `(4)`, добавляя «await» после «for». Он
   вызовет `range[Symbol.asyncIterator]()` один раз, а затем его метод `next()` для получения значений.

Вот небольшая шпаргалка:

|                                          | Итераторы | Асинхронные итераторы |
|------------------------------------------| ------ |-----------------|
| Метод для создания итерируемого объекта  | Symbol.iterator | Symbol.asyncIterator|
| next() возвращает	                       | любое значение | промис |
| для цикла используйте	                   | for..of	| for await..of|

**Оператор расширения `...` не работает асинхронно**

Функции, которые требуют обычных синхронных итераторов, не работают с асинхронными.

Например, оператор расширения (три точки `...`) не будет работать:

        alert( [...range] ); // Ошибка, нет Symbol.iterator

Это естественно, так как он ожидает `Symbol.iterator`, как и `for..of` без `await`. Ему не
подходит `Symbol.asyncIterator`.

