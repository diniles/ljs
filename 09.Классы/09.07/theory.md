# Примеси

#### [Примеси](https://learn.javascript.ru/mixins)

В JavaScript можно наследовать только от одного объекта. Объект имеет единственный `[[Prototype]]`. И класс может
расширить только один другой класс.

Для таких случаев существуют «примеси».

По определению из
Википедии, [примесь](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
– это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.

Другими словами, примесь определяет методы, которые реализуют определённое поведение. Мы не используем примесь саму по
себе, а используем её, чтобы добавить функциональность другим классам.

### Пример примеси

В примере ниже примесь `sayHiMixin` имеет методы, которые придают объектам класса User возможность вести разговор:

      // примесь
      let sayHiMixin = {
      sayHi() {
      alert(`Привет, ${this.name}`);
      },
      sayBye() {
      alert(`Пока, ${this.name}`);
      }
      };
      
      // использование:
      class User {
      constructor(name) {
      this.name = name;
      }
      }
      
      // копируем методы
      Object.assign(User.prototype, sayHiMixin);
      
      // теперь User может сказать Привет
      new User("Вася").sayHi(); // Привет, Вася!

Примеси могут наследовать друг друга.

В примере ниже `sayHiMixin` наследует от `sayMixin`:

      let sayMixin = {
      say(phrase) {
      alert(phrase);
      }
      };
      
      let sayHiMixin = {
      __proto__: sayMixin, // (или мы можем использовать Object.create для задания прототипа)
      
      sayHi() {
      // вызываем метод родителя
      super.say(`Привет, ${this.name}`); // (*)
      },
      sayBye() {
      super.say(`Пока, ${this.name}`); // (*)
      }
      };
      
      class User {
      constructor(name) {
      this.name = name;
      }
      }
      
      // копируем методы
      Object.assign(User.prototype, sayHiMixin);
      
      // теперь User может сказать Привет
      new User("Вася").sayHi(); // Привет, Вася!

Обратим внимание, что при вызове родительского метода `super.say()` из `sayHiMixin` (строки, помеченные `(*)`) этот
метод ищется в прототипе самой примеси, а не класса.

### EventMixin

Многие объекты в браузерной разработке (и не только) обладают важной способностью – они могут генерировать события.
События – отличный способ передачи информации всем, кто в ней заинтересован. Давайте создадим примесь, которая позволит
легко добавлять функциональность по работе с событиями любым классам/объектам.

- Примесь добавит метод `.trigger(name, [data])` для генерации события. Аргумент name – это имя события, за которым
  могут следовать другие аргументы с данными для события.
- Также будет добавлен метод `.on(name, handler)`, который назначает обработчик для события с заданным именем.
  Обработчик будет вызван, когда произойдёт событие с указанным именем `name`, и получит данные из `.trigger`.
- …и метод `.off(name, handler)`, который удаляет обработчик указанного события.

После того, как все методы примеси будут добавлены, объект `user` сможет сгенерировать событие `"login"` после входа
пользователя в личный кабинет. А другой объект, к примеру, `calendar` сможет использовать это событие, чтобы показывать
зашедшему пользователю актуальный для него календарь.

Или menu может генерировать событие `"select"`, когда элемент меню выбран, а другие объекты могут назначать обработчики,
чтобы реагировать на это событие, и т.п.

Вот код примеси:

      let eventMixin = {
         /** Подписаться на событие, использование: menu.on('select', function(item) {... } */
             on(eventName, handler) {
                if (!this._eventHandlers) this._eventHandlers = {};
                if (!this._eventHandlers[eventName]) {
                  this._eventHandlers[eventName] = [];
             }
             this._eventHandlers[eventName].push(handler);
          },
      
      /** Отменить подписку, использование:  menu.off('select', handler)    */
          off(eventName, handler) {
             let handlers = this._eventHandlers && this._eventHandlers[eventName];
             if (!handlers) return;
                for (let i = 0; i < handlers.length; i++) {
                  if (handlers[i] === handler) {
                     handlers.splice(i--, 1);
                }
             }
          },
      
      /** Сгенерировать событие с указанным именем и данными this.trigger('select', data1, data2); */
          trigger(eventName, ...args) {
            if (!this._eventHandlers || !this._eventHandlers[eventName]) {
               return; // обработчиков для этого события нет
          }
      
            // вызовем обработчики
            this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
        }
        };

Итак, у нас есть 3 метода:

1. `.on(eventName, handler)` – назначает функцию `handler`, чтобы обработать событие с заданным именем. Обработчики
   хранятся в свойстве `_eventHandlers`, представляющим собой объект, в котором имя события является ключом, а массив
   обработчиков – значением.

2. `.off(eventName, handler)` – убирает функцию из списка обработчиков.

3. `.trigger(eventName, ...args)` – генерирует событие: все назначенные обработчики из `_eventHandlers[eventName]`
   вызываются, и `...args` передаются им в качестве аргументов.

Использование:

      // Создадим класс
      class Menu {
         choose(value) {
            this.trigger("select", value);
         }
      }
      // Добавим примесь с методами для событий
      Object.assign(Menu.prototype, eventMixin);
      
      let menu = new Menu();
      
      // Добавить обработчик, который будет вызван при событии "select":
      menu.on("select", value => alert(`Выбранное значение: ${value}`));
      
      // Генерирует событие => обработчик выше запускается и выводит:
      menu.choose("123"); // Выбранное значение: 123

Теперь если у нас есть код, заинтересованный в событии `"select"`, то он может слушать его с помощью `menu.on(...)`.

А `eventMixin` позволяет легко добавить такое поведение в любой класс без вмешательства в цепочку наследования.