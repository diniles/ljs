# Проверка класса: "instanceof"

#### [Проверка класса: "instanceof"]https://learn.javascript.ru/instanceof)

Оператор `instanceof` позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.

Такая проверка может потребоваться во многих случаях. Здесь мы используем её для создания полиморфной функции, которая
интерпретирует аргументы по-разному в зависимости от их типа.

### Оператор instanceof

Синтаксис:

    obj instanceof Class

Оператор вернёт `true`, если `obj` принадлежит классу `Class` или наследующему от него.

Также это работает с функциями-конструкторами

…И для встроенных классов, таких как `Array`:

    let arr = [1, 2, 3];
    alert( arr instanceof Array ); // true
    alert( arr instanceof Object ); // true

Пожалуйста, обратите внимание, что `arr` также принадлежит классу `Object`, потому что `Array` наследует от `Object`.

Обычно оператор `instanceof` просматривает для проверки цепочку прототипов. Но это поведение может быть изменено при
помощи статического метода `Symbol.hasInstance`.

Алгоритм работы `obj instanceof Class` работает примерно так:

1. Если имеется статический метод `Symbol.hasInstance`, тогда вызвать его: `Class[Symbol.hasInstance]`(obj). Он должен
   вернуть либо `true`, либо `false`, и это конец. Это как раз и есть возможность ручной настройки `instanceof`.
2. Большая часть классов не имеет метода `Symbol.hasInstance`. В этом случае используется стандартная логика:
   проверяется, равен ли `Class.prototype` одному из прототипов в прототипной цепочке `obj`.

### Бонус: Object.prototype.toString возвращает тип

Мы уже знаем, что обычные объекты преобразуются к строке как `[object Object]`:

    let obj = {};
    
    alert(obj); // [object Object]
    alert(obj.toString()); // то же самое

Так работает реализация метода `toString`. Но у `toString` имеются скрытые возможности, которые делают метод гораздо
более мощным. Мы можем использовать его как расширенную версию `typeof` и как альтернативу `instanceof`.

Согласно [спецификации](https://tc39.github.io/ecma262/#sec-object.prototype.tostring) встроенный метод `toString` может
быть позаимствован у объекта и вызван в контексте любого
другого значения. И результат зависит от типа этого значения.

- Для числа это будет `[object Number]`
- Для булева типа это будет `[object Boolean]`
- Для `null`: `[object Null]`
- Для `undefined`: `[object Undefined]`
- Для массивов: `[object Array]`
- …и т.д. (поведение настраивается).

### Symbol.toStringTag

Поведение метода объектов toString можно настраивать, используя специальное свойство объекта Symbol.toStringTag.

Например:

    let user = {
    [Symbol.toStringTag]: "User"
    };
    
    alert( {}.toString.call(user) ); // [object User]

Как вы можете видеть, результат – это значение `Symbol.toStringTag` (если он имеется) обёрнутое в `[object ...]`.

В итоге мы получили «typeof на стероидах», который не только работает с примитивными типами данных, но также и со
встроенными объектами, и даже может быть настроен.

Можно использовать `{}.toString.call` вместо `instanceof` для встроенных объектов, когда мы хотим получить тип в виде
строки, а не просто сделать проверку.

### Итого

работает для возвращает
typeof примитивов строка
{}.toString примитивов, встроенных объектов, объектов с Symbol.toStringTag строка
instanceof объектов true/false

Как мы можем видеть, технически `{}.toString` «более продвинут», чем `typeof`.

А оператор `instanceof` – отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом
наследования.

