# Декораторы и переадресация вызова, call/apply

#### [Декораторы и переадресация вызова, call/apply](https://learn.javascript.ru/call-apply-decorators)

### Прозрачное кеширование

Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления, но возвращающая стабильные результаты.
Другими словами, для одного и того же x она всегда возвращает один и тот же результат.

Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) возвращаемые ею результаты, чтобы
сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим её в функцию-обёртку – «wrapper» (от
англ. «wrap» – обёртывать), которая добавит кеширование. Далее мы увидим, что в таком подходе масса преимуществ.

Вот код с объяснениями:

    function slow(x) {
    // здесь могут быть ресурсоёмкие вычисления
        alert(`Called with ${x}`);
        return x;
    }
    
    function cachingDecorator(func) {
        let cache = new Map();
        
        return function(x) {
            if (cache.has(x)) {    // если кеш содержит такой x,
                return cache.get(x); // читаем из него результат
        }
        
            let result = func(x); // иначе, вызываем функцию
        
            cache.set(x, result); // и кешируем (запоминаем) результат
            return result;
        };
    }
    
    slow = cachingDecorator(slow);
    
    alert( slow(1) ); // slow(1) кешируем
    alert( "Again: " + slow(1) ); // возвращаем из кеша
    
    alert( slow(2) ); // slow(2) кешируем
    alert( "Again: " + slow(2) ); // возвращаем из кеша

В коде выше `cachingDecorator` – это декоратор, специальная функция, которая принимает другую функцию и изменяет её
поведение.

Идея состоит в том, что мы можем вызвать `cachingDecorator` с любой функцией, в результате чего мы получим кеширующую
обёртку. Это здорово, т.к. у нас может быть множество функций, использующих такую функциональность, и всё, что нам нужно
сделать – это применить к ним `cachingDecorator`.

Отделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.

Подводя итог, можно выделить несколько преимуществ использования отдельной `cachingDecorator` вместо изменения кода
самой slow:

- Функцию `cachingDecorator` можно использовать повторно. Мы можем применить её к другой функции.
- Логика кеширования является отдельной, она не увеличивает сложность самой `slow` (если таковая была).
- При необходимости мы можем объединить несколько декораторов (речь об этом пойдёт позже).

### Применение «func.call» для передачи контекста.

Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

Существует специальный встроенный метод функции `func.call(context, …args)`, который позволяет вызывать функцию, явно
устанавливая `this`.

Синтаксис:

    func.call(context, arg1, arg2, ...)

Он запускает функцию `func`, используя первый аргумент как её контекст `this`, а последующие – как её аргументы.

Здесь мы используем `call` для вызова `say` с заданным контекстом и фразой:

    function say(phrase) {
        alert(this.name + ': ' + phrase);
    }
    
    let user = { name: "John" };
    
    // 'user' становится 'this', и "Hello" становится первым аргументом
    say.call( user, "Hello" ); // John: Hello

В нашем случае мы можем использовать `call` в обёртке для передачи контекста в исходную функцию:

    let worker = {
        someMethod() {
        return 1;
        },
    
        slow(x) {
            alert("Called with " + x);
            return x * this.someMethod(); // (*)
        }
    };
    
    function cachingDecorator(func) {
        let cache = new Map();
            return function(x) {
            if (cache.has(x)) {
            return cache.get(x);
            }
        let result = func.call(this, x); // теперь 'this' передаётся правильно
        cache.set(x, result);
        return result;
        };
    }
    
    worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей
    
    alert( worker.slow(2) ); // работает
    alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)

Чтобы всё было понятно, давайте посмотрим глубже, как передаётся this:

1. После декорации `worker.slow` становится обёрткой `function (x) { ... }`.
2. Так что при выполнении `worker.slow(2)` обёртка получает `2` в качестве аргумента и `this=worker` (так как это объект
   перед точкой).
3. Внутри обёртки, если результат ещё не кеширован, `func.call(this, x)` передаёт текущий `this (=worker)` и текущий
   аргумент `(=2)` в оригинальную функцию.

### Переходим к нескольким аргументам с «func.apply»

Как же кешировать метод с несколькими аргументами worker.slow?

    let worker = {
        slow(min, max) {
        return min + max; // здесь может быть тяжёлая задача
        }
    };
    
    // будет кешировать вызовы с одинаковыми аргументами
    worker.slow = cachingDecorator(worker.slow);

Здесь у нас есть две задачи для решения.

Во-первых, как использовать оба аргумента `min` и `max` для ключа в коллекции `cache`? Ранее для одного аргумента `x` мы
могли просто сохранить результат `cache.set(x, result)` и вызвать c`ache.get(x)`, чтобы получить его позже. Но теперь
нам нужно запомнить результат для комбинации аргументов `(min,max)`. Встроенный `Map` принимает только одно значение как
ключ.

Есть много возможных решений:

1. Реализовать новую (или использовать стороннюю) структуру данных для коллекции, которая более универсальна, чем
   встроенный `Map`, и поддерживает множественные ключи.
2. Использовать вложенные коллекции: `cache.set(min)` будет `Map`, которая хранит пару `(max, result)`. Тогда
   получить `result` мы сможем, вызвав `cache.get(min).get(max)`.
2. Соединить два значения в одно. В нашем конкретном случае мы можем просто использовать строку `min,max` как ключ
   к `Map`. Для гибкости, мы можем позволить передавать хеширующую функцию в декоратор, которая знает, как сделать одно
   значение из многих.

Для многих практических применений третий вариант достаточно хорош, поэтому мы будем придерживаться его.

Также нам понадобится заменить `func.call(this, x)` на `func.call(this, ...arguments)`, чтобы передавать все аргументы
обёрнутой функции, а не только первый.

Вот более мощный `cachingDecorator`:

    let worker = {
        slow(min, max) {
        alert(`Called with ${min},${max}`);
        return min + max;
        }
    };
    
    function cachingDecorator(func, hash) {
        let cache = new Map();
        return function() {
        let key = hash(arguments); // (*)
            if (cache.has(key)) {
                return cache.get(key);
            }
        
            let result = func.call(this, ...arguments); // (**)
        
            cache.set(key, result);
            return result;
        };
    }
    
    function hash(args) {
        return args[0] + ',' + args[1];
    }
    
    worker.slow = cachingDecorator(worker.slow, hash);
    
    alert( worker.slow(3, 5) ); // работает
    alert( "Again " + worker.slow(3, 5) ); // аналогично (из кеша)

Теперь он работает с любым количеством аргументов.

Есть два изменения:

- В строке `(*)` вызываем `hash` для создания одного ключа из arguments. Здесь мы используем простую функцию
  «объединения», которая превращает аргументы `(3, 5)` в ключ `3,5`. В более сложных случаях могут потребоваться другие
  функции хеширования.
- Затем в строке `(**)` используем `func.call(this, ...arguments)` для передачи как контекста, так и всех аргументов,
  полученных обёрткой (независимо от их количества), в исходную функцию.

Вместо `func.call(this, ...arguments)` мы могли бы написать `func.apply(this, arguments)`.

Синтаксис встроенного метода `func.apply`:

    func.apply(context, args)

    Он выполняет `func`, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.

Единственная разница в синтаксисе между `call` и `apply` состоит в том, что `call` ожидает список аргументов, в то время
как apply принимает псевдомассив.

### Заимствование метода

Теперь давайте сделаем ещё одно небольшое улучшение функции хеширования:

    function hash(args) {
        return args[0] + ',' + args[1];
    }

На данный момент она работает только для двух аргументов. Было бы лучше, если бы она могла склеить любое
количество `args`.

Есть простой способ использовать соединение массива:

    function hash() {
        alert( [].join.call(arguments) ); // 1,2
    }
    
    hash(1, 2);

Этот трюк называется _заимствование метода_.

Мы берём (заимствуем) метод `join` из обычного массива `[].join`. И используем `[].join.call`, чтобы выполнить его в
контексте arguments.

Почему это работает?

Это связано с тем, что внутренний алгоритм встроенного метода `arr.join(glue)` очень прост. Взято из спецификации
практически «как есть»:

1. Пускай первым аргументом будет `glue` или, в случае отсутствия аргументов, им будет запятая "`,`"
2. Пускай `result` будет пустой строкой "``".
3. Добавить `this[0]` к `result`.
4. Добавить `glue` и `this[1]`.
5. Добавить `glue` и `this[2]`.
6. …выполнять до тех пор, пока `this.length` элементов не будет склеено.
7. Вернуть `result`.
   Таким образом, технически он принимает `this` и объединяет `this[0], this[1]`… и т.д. вместе. Он намеренно написан
   так, что допускает любой псевдомассив `this` (не случайно, многие методы следуют этой практике). Вот почему он также
   работает с
   `this=arguments`.