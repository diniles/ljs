# Proxy и Reflect

#### [Proxy и Reflect](https://learn.javascript.ru/proxy)

Объект `Proxy` «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие. Далее мы будем называть такие объекты «прокси».

Прокси используются во многих библиотеках и некоторых браузерных фреймворках. В этой главе мы увидим много случаев применения прокси в решении реальных задач.

Синтаксис:

    let proxy = new Proxy(target, handler);

- `target` – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
- `handler` – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка `get` – для чтения свойства из `target`, ловушка `set` – для записи свойства в `target` и так далее.
  При операциях над `proxy`, если в `handler` имеется соответствующая «ловушка», то она срабатывает, и прокси имеет возможность по-своему обработать её, иначе операция будет совершена над оригинальным объектом `target`.

В качестве начального примера создадим прокси без всяких ловушек:

    let target = {};
    let proxy = new Proxy(target, {}); // пустой handler

    proxy.test = 5; // записываем в прокси (1)
    alert(target.test); // 5, свойство появилось в target!

    alert(proxy.test); // 5, мы также можем прочитать его из прокси (2)

    for(let key in proxy) alert(key); // test, итерация работает (3)

Так как нет ловушек, то все операции на `proxy` применяются к оригинальному объекту target.

1. Запись свойства `proxy.test=` устанавливает значение на `target`.
2. Чтение свойства `proxy.test` возвращает значение из `target`.
3. Итерация по `proxy` возвращает значения из `target`.

Как мы видим, без ловушек proxy является прозрачной обёрткой над `target`.

`Proxy` – это особый, «экзотический», объект, у него нет собственных свойств. С пустым `handler` он просто перенаправляет все операции на `target`.

Чтобы активировать другие его возможности, добавим ловушки.

Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять. Например, `[[Get]]` – внутренний метод для чтения свойства, `[[Set]]` – для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к ним по имени.

Ловушки как раз перехватывают вызовы этих внутренних методов. Полный список методов, которые можно перехватывать, перечислен в [спецификации Proxy](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots), а также в таблице ниже.

Для каждого внутреннего метода в этой таблице указана ловушка, то есть имя метода, который мы можем добавить в параметр `handler` при создании `new Proxy`, чтобы перехватывать данную операцию:

| Внутренний метод        | Ловушка                    | Что вызывает                                                                                                                                                                                                                                                                                                              |
| ----------------------- | -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `[[Get]]`               | `get`                      | чтение свойства                                                                                                                                                                                                                                                                                                           |
| `[[Set]]`               | `set`                      | запись свойства                                                                                                                                                                                                                                                                                                           |
| `[[HasProperty]]`       | `has`                      | оператор `in`                                                                                                                                                                                                                                                                                                             |
| `[[Delete]]`            | `deleteProperty`           | оператор delete                                                                                                                                                                                                                                                                                                           |
| `[[Call]]`              | `apply`                    | вызов функции                                                                                                                                                                                                                                                                                                             |
| `[[Construct]]`         | `construct`                | оператор `new`                                                                                                                                                                                                                                                                                                            |
| `[[GetPrototypeOf]]`    | `getPrototypeOf`           | [Object.getPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)                                                                                                                                                                                              |
| `[[SetPrototypeOf]]`    | `setPrototypeOf`           | [Object.setPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)                                                                                                                                                                                              |
| `[[IsExtensible]]`      | `isExtensible`             | [Object.isExtensible](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)                                                                                                                                                                                                  |
| `[[PreventExtensions]]` | `preventExtensions`        | [Object.preventExtensions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)                                                                                                                                                                                        |
| `[[DefineOwnProperty]]` | `defineProperty`           | [Object.defineProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), [Object.defineProperties](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)                                                            |
| `[[GetOwnProperty]]`    | `getOwnPropertyDescriptor` | [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor), `for..in, Object.keys/values/entries`                                                                                                                                   |
| `[[OwnPropertyKeys]]`   | `ownKeys`                  | [Object.getOwnPropertyNames](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames), [Object.getOwnPropertySymbols](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), `for..in, Object.keys/values/entries` |

**Инварианты**

JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.

Большинство из них касаются возвращаемых значений:

- Метод `[[Set]]` должен возвращать `true`, если значение было успешно записано, иначе `false`.
- Метод `[[Delete]]` должен возвращать `true`, если значение было успешно удалено, иначе `false`.
- …и так далее, мы увидим больше в примерах ниже.

Есть и другие инварианты, например:

- Метод `[[GetPrototypeOf]]`, применённый к прокси, должен возвращать то же значение, что и метод `[[GetPrototypeOf]]`, применённый к оригинальному объекту. Другими словами, чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.
  Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия.

Инварианты гарантируют корректное и последовательное поведение конструкций и методов языка. Полный список инвариантов можно найти в [спецификации](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots), хотя скорее всего вы не нарушите эти условия, если только не соберётесь делать что-то совсем уж странное.

### Значение по умолчанию с ловушкой «get»

Чаще всего используются ловушки на чтение/запись свойств.

Чтобы перехватить операцию чтения, `handler` должен иметь метод `get(target, property, receiver)`.

Он срабатывает при попытке прочитать свойство объекта, с аргументами:

- `target` – это оригинальный объект, который передавался первым аргументом в конструктор `new Proxy`,
- `property` – имя свойства,
- `receiver` – если свойство объекта является геттером, то `receiver` – это объект, который будет использован как `this` при его вызове. Обычно это сам объект прокси (или наследующий от него объект). Прямо сейчас нам не понадобится этот аргумент, подробнее разберём его позже.

Давайте применим ловушку `get`, чтобы реализовать «значения по умолчанию» для свойств объекта.

Например, сделаем числовой массив, так чтобы при чтении из него несуществующего элемента возвращался `0`.

Обычно при чтении из массива несуществующего свойства возвращается `undefined`, но мы обернём обычный массив в прокси, который перехватывает операцию чтения свойства из массива и возвращает `0`, если такого элемента нет:

    let numbers = [0, 1, 2];

    numbers = new Proxy(numbers, {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        } else {
          return 0; // значение по умолчанию
        }
      }
    });

    alert( numbers[1] ); // 1
    alert( numbers[123] ); // 0 (нет такого элемента)

Мы можем использовать `Proxy` для реализации любой логики возврата значений по умолчанию.

Представим, что у нас есть объект-словарь с фразами на английском и их переводом на испанский:

    let dictionary = {
      'Hello': 'Hola',
      'Bye': 'Adiós'
    };

    alert( dictionary['Hello'] ); // Hola
    alert( dictionary['Welcome'] ); // undefined

Сейчас, если фразы в `dictionary` нет, при чтении возвращается `undefined`. Но на практике оставлять фразы непереведёнными лучше, чем использовать `undefined`. Поэтому давайте сделаем так, чтобы при отсутствии перевода возвращалась оригинальная фраза на английском вместо `undefined`.

Чтобы достичь этого, обернём `dictionary` в прокси, перехватывающий операцию чтения:

    let dictionary = {
      'Hello': 'Hola',
      'Bye': 'Adiós'
    };

    dictionary = new Proxy(dictionary, {
      get(target, phrase) { // перехватываем чтение свойства в dictionary
        if (phrase in target) { // если перевод для фразы есть в словаре
          return target[phrase]; // возвращаем его
        } else {
          // иначе возвращаем непереведённую фразу
          return phrase;
        }
      }
    });

    // Запросим перевод произвольного выражения в словаре!
    // В худшем случае оно не будет переведено
    alert( dictionary['Hello'] ); // Hola
    alert( dictionary['Welcome to Proxy']); // Welcome to Proxy (нет перевода)

**Прокси следует использовать везде вместо `target`**

Пожалуйста, обратите внимание: прокси перезаписывает переменную:

    dictionary = new Proxy(dictionary, ...);

Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться.

### Валидация с ловушкой «set»

Допустим, мы хотим сделать массив исключительно для чисел. Если в него добавляется значение иного типа, то это должно приводить к ошибке.

Ловушка `set` срабатывает, когда происходит запись свойства.

    set(target, property, value, receiver):

- `target` – это оригинальный объект, который передавался первым аргументом в конструктор `new Proxy`,
- `property` – имя свойства,
- `value` – значение свойства,
- `receiver` – аналогично ловушке `get`, этот аргумент имеет значение, только если свойство – сеттер.
  Ловушка `set` должна вернуть `true`, если запись прошла успешно, и `false` в противном случае (будет сгенерирована ошибка `TypeError`).

Давайте применим её для проверки новых значений:

    let numbers = [];

    numbers = new Proxy(numbers, { // (*)
      set(target, prop, val) { // для перехвата записи свойства
        if (typeof val == 'number') {
          target[prop] = val;
          return true;
        } else {
          return false;
        }
      }
    });

    numbers.push(1); // добавилось успешно
    numbers.push(2); // добавилось успешно
    alert("Длина: " + numbers.length); // 2

    numbers.push("тест"); // TypeError (ловушка set на прокси вернула false)

    alert("Интерпретатор никогда не доходит до этой строки (из-за ошибки в строке выше)");

Обратите внимание, что встроенная функциональность массива по-прежнему работает! Значения добавляются методом `push`. Свойство `length` при этом увеличивается. Наш прокси ничего не ломает.

Нам не нужно переопределять методы массива `push` и `unshift` и другие, чтобы добавлять туда проверку на тип, так как внутри себя они используют операцию `[[Set]]`, которая перехватывается прокси.

Таким образом, код остаётся чистым и прозрачным.

**Не забывайте вернуть `true`**

Как сказано ранее, нужно соблюдать инварианты.

Для `set` реализация ловушки должна возвращать `true` в случае успешной записи свойства.

Если забыть это сделать или возвратить любое ложное значение, это приведёт к ошибке `TypeError`.

### Перебор при помощи «ownKeys» и «getOwnPropertyDescriptor»

Object.keys, цикл for..in и большинство других методов, которые работают со списком свойств объекта, используют внутренний метод [[OwnPropertyKeys]] (перехватываемый ловушкой `ownKeys`) для их получения.

Такие методы различаются в деталях:

- `Object.getOwnPropertyNames(obj)` возвращает не-символьные ключи.
- `Object.getOwnPropertySymbols(obj)` возвращает символьные ключи.
- `Object.keys/values()` возвращает не-символьные ключи/значения с флагом - `enumerable` (подробнее про флаги свойств было в главе [Флаги и дескрипторы свойств](https://learn.javascript.ru/property-descriptors)).
- `for..in` перебирает не-символьные ключи с флагом enumerable, а также ключи прототипов.

…Но все они начинают с этого списка.

В примере ниже мы используем ловушку `ownKeys`, чтобы цикл `for..in` по объекту, равно как `Object.keys` и `Object.values` пропускали свойства, начинающиеся с подчёркивания `_`:

    let user = {
      name: "Вася",
      age: 30,
      _password: "***"
    };

    user = new Proxy(user, {
      ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'));
      }
    });

    // ownKeys исключил _password
    for(let key in user) alert(key); // name, затем: age

    // аналогичный эффект для этих методов:
    alert( Object.keys(user) ); // name,age
    alert( Object.values(user) ); // Вася,30

Впрочем, если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то `Object.keys` его не выдаст:

    let user = { };

    user = new Proxy(user, {
      ownKeys(target) {
        return ['a', 'b', 'c'];
      }
    });

    alert( Object.keys(user) ); // <пусто>

Почему? Причина проста: `Object.keys` возвращает только свойства с флагом enumerable. Для того, чтобы определить, есть ли этот флаг, он для каждого свойства вызывает внутренний метод `[[GetOwnProperty]]`, который получает его дескриптор. А в данном случае свойство отсутствует, его [дескриптор](https://learn.javascript.ru/property-descriptors) пуст, флага `enumerable` нет, поэтому оно пропускается.

Чтобы `Object.keys` возвращал свойство, нужно либо чтобы свойство в объекте физически было, причём с флагом `enumerable`, либо перехватить вызовы `[[GetOwnProperty]]` (это делает ловушка `getOwnPropertyDescriptor`), и там вернуть дескриптор с `enumerable: true`.

Вот так будет работать:

    let user = { };

    user = new Proxy(user, {
      ownKeys(target) { // вызывается 1 раз для получения списка свойств
        return ['a', 'b', 'c'];
      },

      getOwnPropertyDescriptor(target, prop) { // вызывается для каждого свойства
        return {
          enumerable: true,
          configurable: true
          /* ...другие флаги, возможно, "value: ..." */
        };
      }

    });

    alert( Object.keys(user) ); // a, b, c

Ещё раз заметим, что получение дескриптора нужно перехватывать только если свойство отсутствует в самом объекте.

### Защищённые свойства с ловушкой «deleteProperty» и другими
